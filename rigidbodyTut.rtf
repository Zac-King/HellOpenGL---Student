{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}{\f1\fnil Consolas;}{\f2\fnil\fcharset0 Consolas;}{\f3\fnil\fcharset161 Calibri;}}
{\colortbl ;\red0\green0\blue255;\red255\green255\blue255;\red0\green0\blue0;\red43\green145\blue175;\red0\green128\blue0;\red128\green128\blue128;\red111\green0\blue138;}
{\*\generator Riched20 6.3.9600}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\f0\fs22\lang9 I've moved all of the math stuff to \b cmathutils\b0 . Take an opportunity to check it out. Now that we're going to jump into physics, it's important that we don't modify the w-component of any given column in the transform-- all of the physics math will be with \b vec3\b0  or \b vec2\b0 .\b\par
Transform conveniences:\line\tab\b0 Providing easy access to \i up\i0 , \i right\i0 , and \i position\i0  vectors inside of a transform can make it a lot easier to think about what's going. A \i reference\i0  variable could be useful in this case. We need the information formatted as \b vec3\b0  since we want to preserve that w-component.\par
In your transform class, go ahead and add \i reference\i0  variable \b vec3\b0 's for \i up, right\i0  and \i position.\par
\cf1\highlight2\i0\f1\fs19 class\cf3  \cf4 Transform\cf3\f2\lang1033\line\f1\lang9\{\line\cf1 public\cf3 :\line\f2\lang1033\tab\cf4\f1\lang9 Matrix4\cf3  m_local;\line\tab\cf4 Transform\cf3  *m_parent;\line\f2\lang1033\tab\cf4\b\f1\lang9 vec3\cf3  &up, &right,\f2\lang1033  &forward,\f1\lang9  &position;\b0\line\cf5 //...\par
\cf0\highlight0\f0\fs22 Normally you can't create a reference variable without telling it what it's referring to, but it's okay with a class if we use the \i initializer list\i0 .\par
\cf3\highlight2\f1\fs19 Transform(\cf5 /*params....*/\cf3 )\line\f2\lang1033   \f1\lang9 :  right(m_local.v[0]), up(m_local.v[1]),\f2\lang1033\line      forward(m_local.v[2])\f1\lang9  position(m_local.v[3])\f2\lang1033  \f1\lang9\{ \}\par
\cf0\highlight0\f0\fs22 Unfortunately, this won't actually work! the \i v\i0 -property in \i mat4\i0  is an array of \b vec4\b0 , not \b vec3\b0 . Cool thing about vec3 and vec4 is that they are laid out in memory in the same way, vec4 just has an extra 4-bytes for it's w-component. We can do some type-casting magic to get our references for vec3's to look at only the first 3 values of the vec4 columns in the matrix.\par
First: take the \i address of \i0 the column we want. This gives us a memory address.\line\tab\cf3\highlight2\f1\fs19 right(\b\f2\lang1033 &\b0\f1\lang9 m_local.v[0])\f2\lang1033 ,\f1\lang9\line\line\cf0\highlight0\f0\fs22 Second: \i Cast \i0 the memory address as a vec3 pointer.\line\tab\cf3\highlight2\f1\fs19 right(\b\f2\lang1033 (vec3*)\b0 &\f1\lang9 m_local.v[0])\f2\lang1033 ,\f1\lang9\line\line\cf0\highlight0\f0\fs22 Finally: dereference the casted pointer.\line\tab\cf3\highlight2\f1\fs19 right(\b\f2\lang1033 *\b0 (vec3*)&\f1\lang9 m_local.v[0])\f2\lang1033 ,\line\line\cf0\highlight0\i\f0\fs22\lang9 right\i0  will now use the same memory address as m_local.v[0]! Since \i right\i0  is a vec3, it can't be used to mess with the \i affine\i0  w-component, but the x,y,z's all line up.\par
 Get all your references set properly!\par
\b Rigidbody Physics:\line\tab\b0 Physics is built up around the idea of \i integration.\i0  Integration is a math concept whereby a value is modified over time. In a game, time is typically the engine that drives a simulation forward, so \i integration\i0  is what we do.\par
We'll be using the simplest kind of integration-- \i Euler\i0  \i Integration (note that Euler Integration is woefully inaccurate, but since everything in a game is both relative and a bunch of arbitrary approximations-- it doesn't matter if the game is fun).\i0\par
The idea and principle, in a mathy sense, is pretty straightforward:\line\tab\i y' = y +  \f3\lang1032\'c4\f0\lang1033 y *  \f3\lang1032\'c4\f0\lang1033 t\b\lang9\par
\b0\i0 In english:\line\tab\i y'\i0    : new value\line\tab\i y\i0     : current value\line\tab\i\f3\lang1032\'c4\f0\lang1033 y\i0  : change in value\line\tab\i\f3\lang1032\'c4\f0\lang1033 t\i0   : change in time (delta time)\par
\lang9 So what? It's how we update position!\line\tab\cf3\highlight2\f1\fs19 position = position + velocity * \cf6 dt\cf3 ;\cf0\highlight0\b\f0\fs22\par
\b0 There are a few key terms in physics that are useful.\b\line\tab\b0 Position                          : The immediate location of an object.\line\tab Velocity                          : Rate of change of position (how fast position changes).\line\tab Acceleration                   : Rate of change of velocity (how fast velocity changes).\line\tab Direction        \tab              : The immediate facing of an object.\line\tab Angular Momentum       : rate of change of direction (how fast an object is spinning).\line\tab Torque                            : Rate of change of angular Momentum.\par
From a technical point of view, there are other things involved, but this is about as far as it gets useful to simulate (\i Jerk, Jounce, Snap, Crackle and Pop to name a few others).\par
\b\i0\tab Velocity can be thought of as a \i direction\i0  and a \i speed\i0 . In this example, our object will be geared to move in the \i up\i0  direction using a variable to represent speed.\b0\i\par
\i0 We're going to be looking at rigidbody physics- that is, physics as it relates to rigid objects- things that \i don't\i0  change shape-- ie. rocks, spaceships, tanks-- NOT cloth, liquid, or bouncy goo.\par
Make a header and start with the following:\par
\cf1\highlight2\f1\fs19 class\cf3  \cf4 Rigidbody\cf3\line\{\line\cf1 public\cf3 :\line\f2\lang1033\tab\cf4\f1\lang9 vec3\cf3  velocity;\line\tab\cf1 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\f2\lang1033 ;\f1\lang9\line\};\line\par
\f0\fs22\lang1033 A rigidbody is a separate idea from the transform, so we'll put it in a separate class. You can put a rigidbody \i member variable\i0  in either your GameObject base class OR the Tank base class. The idea behind it is that a transform is going to be passed into the update, and the rigidbody will \i integrate\i0  that object's position and rotation using physics.\par
To start- integrate \i position\i0  with \i velocity\i0 .\par
\cf1\f1\fs19 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\line\{\line\tab\cf6 transform\cf3 .position = \cf6 transform\cf3 .position + velocity * \cf6 dt\cf3 ;\line\}\par
\f0\fs22 Since \i velocity\i0  is the change in position, setting the velocity to a value will get the object to move. Note: you may need to play with your \i speed\i0  variable.\par
\cf5\f1\fs19 // in tank\f2 's update\line\cf3\b m_r\f1 igidbody.update(m_transform, \cf6 a_dt\cf3 );\cf1\b0\line if\cf3  (glfwGetKey(\cf6 window\cf3 , \cf7 GLFW_KEY_W\cf3 ))\f2\line\b m_rigidbody.velocity = m_rigidbody.velocity + m_transform.up * m_speed * \cf6\f1 a_dt\cf3\f2 ;\b0\par
\f0\fs22 Instead of immediately stopping, the object will contine to slide in the direction it's moving even after the key is lifted. This is called \i instantaneous acceleration.\i0  That is, an immediate force of acceleration applied to the velocity. Once velocity is \i integrated\i0  by \i immediate acceleration\i0 , it will then go on to \i integrate\i0  into position in the rigidbody's update.\par
This is okay, but we can flesh out our rigidbody class a little bit and simplify our Tank's update.\par
\cf1\f1\fs19\lang9 class\cf3  \cf4 Rigidbody\cf3\line\{\line\cf1 public\cf3 :\line\f2\lang1033\tab\cf4\f1\lang9 vec3\cf3  velocity\f2\lang1033 , \b force\b0\f1\lang9 ;\line\tab\cf1 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\f2\lang1033 ;\f1\lang9\line\f2\lang1033\tab\cf1\b\f1\lang9 void\cf3\f2\lang1033  addForce(\cf4\f1\lang9 vec\f2\lang1033 3\cf3  \cf6 a_force\cf3 );\b0\f1\lang9\line\};\par
\f0\fs22\lang1033 Force is going to serve as a variable to store all of the combined forces (gravity, impulses, movement, etc.) that will be used to modify velocity. We will calculate our actual acceleration using these forces (and some other stuff in a minute). Fortunately, adding a new force is as simple as aggregating it with all existing forces applied to the object.\par
\cf1\b\f1\fs19 void\cf3  addForce(\cf4 vec3\cf3  \cf6 a_force\cf3 )     \{ force = force + \cf6 a_force\cf3 ;  \}\f0\fs22  \b0\line\line\cf1\f1\fs19 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\line\{\line\tab\cf6 transform\cf3 .position = \cf6 transform\cf3 .position + velocity * \cf6 dt\cf3 ;\line\b\f2\tab\cf4\f1 vec3\cf3  acceleration\f2  = force;\f1\line\f2\tab velocity = velocity + \f1 acceleration\f2  * dt;\line\tab force.x = force.y = force.z = 0;\b0\f1\line\}\par
\b\f2 Drag and Mass\b0\f1\line\f2\tab\f0\fs22 This is a good start, but we can further tune the simulation by factoring in \i mass\i0  and \i drag\i0 .\line\tab Mass \tab : How hard it is to move an object.\line\tab Drag      : Dampening force that is always acting against the velocity (friction/inertia).\par
\cf1\f1\fs19\lang9 class\cf3  \cf4 Rigidbody\cf3\line\{\line\cf1 public\cf3 :\line\tab\cf1\b float\cf3  mass, drag;\b0\line\f2\lang1033\tab\cf4\f1\lang9 vec3\cf3  velocity\f2\lang1033 , force\f1\lang9 ;\line\tab\cf1 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\f2\lang1033 ;\f1\lang9\line\f2\lang1033\tab\cf1\f1\lang9 void\cf3\f2\lang1033  addForce(\cf4\f1\lang9 vec\f2\lang1033 3\cf3  \cf6 a_force\cf3 );\f1\lang9\line\};\par
\f0\fs22\lang1033 Formulas (lectures on these later, it's stuff that\i  Newton\i0  figured out):\line\tab Dampening    = Velocity * -Drag\line\tab Force              = Mass * Acceleration - Dampening\line\tab Acceleration  = (Force + Dampening) / Mass\line\line\cf1\f1\fs19 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\line\{\line\tab\cf6 transform\cf3 .position = \cf6 transform\cf3 .position + velocity * \cf6 dt\cf3 ;\line\f2\tab\cf4\b\f1 vec3\cf3\f2  dampening = velocity * -drag;\line\tab\cf4\f1 vec3\cf3  acceleration\f2  = (force + dampening) * (1 / mass);\f1\line\b0\f2\tab velocity = velocity + \f1 acceleration\f2  * dt;\line\tab force.x = force.y = force.z = 0;\f1\line\}\par
\f0\fs22  Now that we have this all setup, we can use it in the tank's update.\par
\cf5\f1\fs19 // in tank land...\cf3\line\cf1 if\cf3  (glfwGetKey(\cf6 window\cf3 , \cf7 GLFW_KEY_W\cf3 ))\line\f2\tab\b\f1 rigidbody.addForce(m_transform.up * m_speed);\b0\par
\f0\fs22 Nice and elegant!\par
\i Velocity\i0  is acted upon by various \i forces\i0 , which in turn \i integrates\i0  into the \i position\i0 , allowing our object to move around. We'll cover the jargon in a bit more depth w/lecture.\par
\b Angular Momentum\b0\line\tab Cool thing is, we can take all this integration mumbo-jumbo and re-use it for rotation. All the formula's are the same.\par
\cf1\f1\fs19\lang9 class\cf3  \cf4 Rigidbody\cf3\line\{\line\cf1 public\cf3 :\line\tab\cf1 float\cf3  mass, drag;\line\f2\lang1033\tab\cf4\f1\lang9 vec3\cf3  velocity\f2\lang1033 , force\f1\lang9 ;\line\f2\lang1033\tab\cf1\b\f1\lang9 float\cf3  angularMomentum, torque;\b0\line\tab\cf1 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\f2\lang1033 ;\f1\lang9\line\f2\lang1033\tab\cf1\f1\lang9 void\cf3\f2\lang1033  addForce(\cf4\f1\lang9 vec\f2\lang1033 3\cf3  \cf6 a_force\cf3 );\line\tab\cf1\b\f1\lang9 void\cf3\f2\lang1033  addTorque(\cf1\f1\lang9 float\cf3\f2\lang1033  \cf6 a_torque\cf3 );\b0\f1\lang9\line\};\par
\f0\fs22\lang1033 Torque will do the same thing for angular momentum as force did for velocity.\line\tab\tab\b Angular Momentum : Torque :: Velocity : Force\b0\line\b Angular Momentum can be thought of as an \i axis\i0  of rotation and a \i torque \i0 in the same way that \i velocity\i0  is a combination of \i direction\i0  and \i speed\i0 .\b0  Therefore, if we want to rotate in a 2D space, we would apply torquing forces along the Z, or \i forward\i0  axis. For now, we're going to ONLY allow rotation along the Z-axis, so angular momentum and torque will be floats, but this can be extended to work with an arbitrary axis of rotation (great for tumbling asteroids)- more on how to do that later. It's a little complicated.\par
First calculate the damping force....\f1\fs19\line\tab\cf1 float\cf3  a_damp = (angularMomentum * -1) * drag;\line\line\f0\fs22 Then the angular acceleration...\f1\fs19\line\f2\tab\cf1\f1 float\cf3  a_acc = (torque + a_damp) * (1 / mass);\line\line\f0\fs22 Then finally the angular momentum...\f1\fs19\line\f2\tab\f1 angularMomentum = angularMomentum + a_acc * \cf6 dt\cf3 ;\line\f2\tab\f1 torque = 0;\par
\f0\fs22 Same as before, so I won't re-explain all the steps. Now, we can actually combine the \i change in rotation (angular velocity)\i0  and \i change in position (velocity)\i0  into a single chain of transformation matrices that is applied to the \i transform\i0 .\par
\cf6\f1\fs19 transform\cf3 .m_local = \line\f2\tab\tab\f1 makeRotation(angularMomentum * \cf6 dt\cf3 )\line\f2\tab\tab\tab\f1 * \cf6 transform\cf3 .m_local\f2\line\tab\tab\tab\tab\f1 *\f2  \f1 makeTranslation(velocity * \cf6 dt\cf3 );\par
\f0\fs22 So... Why apply the transformations in this order?\line\tab Velocities are applied in \i global\i0  space, whereas angular momentum is applied in \i local\i0  space. What does that mean? We apply the velocity first, factor in the old position, and then apply the angular momentum.\par
There will be more lecture on this. The final update function looks something like this:\par
\par
\cf1\f1\fs19 void\cf3  update(\cf4 Transform\cf3  &\cf6 transform\cf3 , \cf1 float\cf3  \cf6 dt\cf3 )\line\{\line\f2\tab\cf6\f1 transform\cf3 .m_local =\line\f2\tab\tab\f1  makeRotation(angularMomentum * \cf6 dt\cf3 )\line\f2\tab\tab\tab\f1 * \cf6 transform\cf3 .m_local\line\tab\f2\tab\tab\tab\f1 * makeTranslation(velocity * \cf6 dt\cf3 );\line\line\f2\tab\cf4\f1 vec3\cf3  damp = (velocity * -1) * drag;\line\f2\tab\cf4\f1 vec3\cf3  acceleration = (force + damp) * (1 / mass);\line\f2\tab\f1 velocity = velocity + acceleration * \cf6 dt\cf3 ;\line\f2\tab\f1 force.x = force.y = force.z = 0;\line\line\f2\tab\cf1\f1 float\cf3  a_damp = (angularMomentum * -1) * drag;\line\f2\tab\cf1\f1 float\cf3  a_acc = (torque + a_damp) * (1 / mass);\line\f2\tab\f1 angularMomentum = angularMomentum + a_acc * \cf6 dt\cf3 ;\line\f2\tab\f1 torque = 0;\line\}\f0\fs22\par
}
 